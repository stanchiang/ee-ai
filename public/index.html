<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Cloudflare AI â€“ Imageâ€‘toâ€‘Circuit Chat (Tabbed Viewer)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @media (max-width: 900px) {
        .split-layout { flex-direction: column; }
        .diagram-pane { max-height: 50vh; }
      }
    </style>
  </head>

  <body class="bg-gray-100">
    <div id="root" class="h-screen"></div>

    <!-- React libs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;
      const readAsDataURL = (f) =>
        new Promise((r, x) => {
          const fr = new FileReader();
          fr.onload = () => r(fr.result);
          fr.onerror = x;
          fr.readAsDataURL(f);
        });

      /* heuristics for ASCII art */
      const looksAsciiArt = (txt) =>
        txt.length > 0 &&
        !/[^\x09\x0A\x0D\x20-\x7E]/.test(txt) &&
        !txt.match(/<\/?[a-z]/i);

      function ChatApp() {
        /* â”€â”€â”€â”€â”€ state â”€â”€â”€â”€â”€ */
        const [messages, setMessages] = useState([
          { role: "system", content: "You are a friendly assistant" },
        ]);
        const [input, setInput] = useState("");
        const [images, setImages] = useState([]);

        /* viewer tabs */
        const [schematic, setSchematic] = useState("");
        const [pcb, setPcb] = useState("");
        const [bom, setBom] = useState("");
        const [activeTab, setActiveTab] = useState("schematic");

        const listRef = useRef(null);
        const controllerRef = useRef(null);

        /* autoâ€‘scroll */
        useEffect(() => {
          listRef.current?.scrollTo({
            top: listRef.current.scrollHeight,
            behavior: "smooth",
          });
        }, [messages]);

        /* ---------- send ---------- */
        async function send() {
          const text = input.trim();
          if (!text && images.length === 0) return;

          /* echo user */
          setMessages((prev) => [
            ...prev,
            {
              role: "user",
              content: { text, imageUrls: images.map((f) => URL.createObjectURL(f)) },
            },
            { role: "assistant", content: "" },   // Empty placeholder for streaming
          ]);
          const placeholderIdx = messages.length + 1;

          const imgs = images;
          setInput("");
          setImages([]);
          controllerRef.current = new AbortController();

          const body = {
            text,
            images: await Promise.all(imgs.map(readAsDataURL)),
            history: messages
              .filter((m) => m.role !== "system")
              .map((m) =>
                typeof m.content === "string"
                  ? m
                  : { role: m.role, content: m.content.text }
              ),
          };

          try {
            const res = await fetch("/api/chat", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
              signal: controllerRef.current.signal,
            });
            if (!res.ok || !res.body)
              throw new Error(`HTTP ${res.status} â€“ ${await res.text()}`);

            const reader = res.body.getReader();
            const decoder = new TextDecoder("utf-8");
            let buffer = "", tail = "";
            
            // Track the active section being processed
            let currentSection = "summary";
            let summaryContent = "";
            let schematicContent = "";
            let pcbContent = "";
            let bomContent = "";
            let lastDetectedSection = null;
            
            // Process the incoming stream
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;

              tail += decoder.decode(value, { stream: true });
              const lines = tail.split(/\r?\n/);
              tail = lines.pop() ?? "";

              for (const line of lines) {
                if (!line.startsWith("data:")) continue;
                const payload = line.slice(5).trim();
                if (payload === "[DONE]") continue;

                try {
                  const obj = JSON.parse(payload);
                  if (typeof obj.response === "string") {
                    // Add to buffer
                    buffer += obj.response;
                    
                    // Check for section markers in the complete buffer
                    const sections = buffer.split(/^\s*=+\s*(\w+)\s*=+\s*$/m);
                    
                    if (sections.length > 1) {
                      // Process each section's content
                      for (let i = 1; i < sections.length; i += 2) {
                        const sectionName = sections[i].toLowerCase();
                        const sectionContent = sections[i + 1]?.trim() || "";
                        
                        // Only process if this is new content for this section
                        const isNewSection = lastDetectedSection !== sectionName;
                        
                        if (isNewSection) {
                          lastDetectedSection = sectionName;
                          
                          // Update content and UI based on section type
                          if (sectionName.startsWith("summary")) {
                            summaryContent = sectionContent;
                            setMessages(prev => {
                              const copy = [...prev];
                              copy[placeholderIdx] = {
                                role: "assistant",
                                content: summaryContent,
                              };
                              return copy;
                            });
                          } else if (sectionName.startsWith("schematic")) {
                            schematicContent = sectionContent;
                            setSchematic(schematicContent);
                            setActiveTab("schematic");
                          } else if (sectionName.startsWith("pcb") || sectionName.startsWith("board")) {
                            pcbContent = sectionContent;
                            setPcb(pcbContent);
                            setActiveTab("pcb");
                          } else if (sectionName.startsWith("bom") || sectionName.includes("list")) {
                            bomContent = sectionContent;
                            setBom(bomContent);
                            setActiveTab("bom");
                          }
                        }
                      }
                    } else {
                      // If we don't have sections yet, update the summary display
                      setMessages(prev => {
                        const copy = [...prev];
                        copy[placeholderIdx] = {
                          role: "assistant",
                          content: buffer,
                        };
                        return copy;
                      });
                    }
                  }
                } catch (parseError) {
                  console.error("Error parsing JSON:", parseError);
                }
              }
            }

            // Final processing when stream is complete
            const blocks = buffer.split(/^\s*=+\s*(\w+)\s*=+\s*$/m);
            
            // Ensure the final content is correctly set
            if (blocks.length > 1) {
              for (let i = 1; i < blocks.length; i += 2) {
                const label = blocks[i]?.toLowerCase() || "";
                const payload = blocks[i + 1]?.trim() || "";
                
                if (label.startsWith("summary")) {
                  setMessages(prev => {
                    const copy = [...prev];
                    copy[placeholderIdx] = {
                      role: "assistant",
                      content: payload,
                    };
                    return copy;
                  });
                } else if (label.startsWith("schematic")) {
                  setSchematic(payload);
                } else if (label.startsWith("pcb") || label.startsWith("board")) {
                  setPcb(payload);
                } else if (label.startsWith("bom") || label.includes("list")) {
                  setBom(payload);
                }
              }
            } else if (buffer.trim()) {
              // No sections found, use entire buffer as content
              setMessages(prev => {
                const copy = [...prev];
                copy[placeholderIdx] = {
                  role: "assistant",
                  content: buffer,
                };
                return copy;
              });
            }
            
            // Return to schematic tab when finished
            setActiveTab("schematic");
          } catch (err) {
            setMessages((prev) => [
              ...prev.slice(0, -1),
              { role: "assistant", content: "Error: " + err.message },
            ]);
          }
        }

        /* ---------- helpers ---------- */
        const onKey = (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            send();
          }
        };
        const stop = () => controllerRef.current?.abort();
        const onFiles = (e) =>
          setImages((prev) => [...prev, ...Array.from(e.target.files ?? [])]);
        const remove = (i) =>
          setImages((prev) => prev.filter((_, idx) => idx !== i));

        /* ---------- UI ---------- */
        return (
          <div className="split-layout flex h-full">
            {/* Chat column */}
            <div className="flex flex-col flex-1 max-w-2xl mx-auto p-4 gap-2">
              {/* chat list */}
              <div
                ref={listRef}
                className="flex-1 overflow-y-auto bg-gray-50 rounded-2xl p-4 shadow-inner space-y-4"
              >
                {messages
                  .filter((m) => m.role !== "system")
                  .map((m, i) => (
                    <div
                      key={i}
                      onClick={() =>
                        m.role === "assistant" &&
                        typeof m.content === "string" && (
                          setActiveTab("schematic"),
                          setSchematic(m.content)
                        )
                      }
                      title={m.role === "assistant" ? "Click to view on right" : undefined}
                      className={
                        "whitespace-pre rounded-2xl p-3 shadow overflow-x-auto overflow-y-auto cursor-pointer " +
                        (m.role === "user"
                          ? "bg-blue-500 text-white self-end"
                          : "bg-white text-gray-900 self-start")
                      }
                    >
                      {Array.isArray(m.content?.imageUrls) &&
                        m.content.imageUrls.length > 0 && (
                          <div className="flex flex-wrap gap-2 mb-2">
                            {m.content.imageUrls.map((src, j) => (
                              <img
                                key={j}
                                src={src}
                                className="w-24 h-24 object-cover rounded-lg"
                              />
                            ))}
                          </div>
                        )}
                      {typeof m.content === "string" ? m.content : m.content.text}
                    </div>
                  ))}
              </div>

              {/* composer */}
              <div className="flex flex-col gap-2">
                {/* image previews */}
                {images.length > 0 && (
                  <div className="flex flex-wrap gap-2">
                    {images.map((file, idx) => (
                      <div key={idx} className="relative">
                        <img
                          src={URL.createObjectURL(file)}
                          className="w-20 h-20 object-cover rounded-lg"
                        />
                        <button
                          onClick={() => remove(idx)}
                          className="absolute -top-2 -right-2 bg-black/60 text-white rounded-full w-5 h-5 text-xs"
                        >
                          Ã—
                        </button>
                      </div>
                    ))}
                  </div>
                )}

                <div className="flex items-end gap-2">
                  <textarea
                    rows="1"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={onKey}
                    placeholder='Describe the circuit you needâ€¦'
                    className="flex-1 resize-none border rounded-2xl p-3 shadow focus:outline-none"
                  ></textarea>

                  <input
                    id="imgInp"
                    type="file"
                    accept="image/*"
                    multiple
                    hidden
                    onChange={onFiles}
                  />
                  <label
                    htmlFor="imgInp"
                    className="cursor-pointer bg-indigo-500 text-white px-4 py-2 rounded-2xl shadow"
                  >
                    ðŸ“·
                  </label>

                  <button
                    onClick={send}
                    disabled={!input.trim() && images.length === 0}
                    className="bg-green-500 text-white px-4 py-2 rounded-2xl shadow disabled:opacity-50"
                  >
                    Send
                  </button>
                  <button
                    onClick={stop}
                    className="bg-red-500 text-white px-4 py-2 rounded-2xl shadow"
                  >
                    Stop
                  </button>
                </div>
                <p className="text-xs text-gray-500 pl-1">
                  Tip: Drop a photo of your timer (or any gadget) and hit "Send" â€“ the
                  AI will reverseâ€‘engineer its circuit.
                </p>
              </div>
            </div>

            {/* Tabbed viewer */}
            <div
              className="diagram-pane w-full max-w-3xl p-4 overflow-auto bg-white shadow-inner border-l border-gray-300"
            >
              {/* tabs */}
              <div className="flex gap-4 border-b mb-3">
                {[
                  ["schematic", "Schematic"],
                  ["pcb", "PCB"],
                  ["bom", "Components"],
                ].map(([key, label]) => (
                  <button
                    key={key}
                    onClick={() => setActiveTab(key)}
                    className={
                      "px-3 py-1 -mb-px border-b-2 " +
                      (activeTab === key
                        ? "border-indigo-600 font-semibold"
                        : "border-transparent text-gray-500 hover:text-gray-800")
                    }
                  >
                    {label}
                  </button>
                ))}
              </div>

              {/* tab bodies */}
              {activeTab === "schematic" &&
                (schematic ? (
                  <pre className="whitespace-pre overflow-auto">{schematic}</pre>
                ) : (
                  <p className="text-gray-500 italic">No schematic yet.</p>
                ))}

              {activeTab === "pcb" &&
                (pcb ? (
                  <pre className="whitespace-pre overflow-auto">{pcb}</pre>
                ) : (
                  <p className="text-gray-500 italic">No PCB layout yet.</p>
                ))}

              {activeTab === "bom" &&
                (bom ? (
                  <ul className="whitespace-pre font-mono space-y-1 overflow-auto">
                    {bom
                      .split(/\n/)
                      .filter((l) => l.trim())
                      .map((line, i) => {
                        const query = line.trim().replace(/\s+/g, "+");
                        return (
                          <li key={i}>
                            <a
                              href={`https://www.amazon.com/s?k=${query}`}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="text-indigo-600 hover:underline"
                            >
                              {line}
                            </a>
                          </li>
                        );
                      })}
                  </ul>
                ) : (
                  <p className="text-gray-500 italic">No component list yet.</p>
                ))}
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<ChatApp />);
    </script>
  </body>
</html>